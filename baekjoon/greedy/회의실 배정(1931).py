# time.sort(key= lambda x : (x[1], x[0]) ) >>> lambda 매개변수 : 표현식
# data_list.sort(key=lambda x : len(x))

# 빨리 끝나는 것 기준, 빨리 시작하는 기준으로 오름차순 정렬
# 가장 빨리 끝난 시간 선택 >> 이후 중에 가장 먼저 시간이 안 겹치는 것 선택 >> cnt 증가 >> 반복
# (0,3) (3,3) >>> 같은 경우를 위해 end time이 같을 경우에 start time이 더 빠른 경우를 선택한다


# for문에서 remove 사용하면 좌측으로 당겨져와 한 index를 넘어가 버린다, 그래서 잘 안 씀


'''
문제
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 
각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 
단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 
회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

입력
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 
둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 
시작 시간과 끝나는 시간은 2**31-1보다 작거나 같은 자연수 또는 0이다.

출력
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

예제 입력 1 
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14

예제 출력 1 
4

'''

n=int(input())
time=[ list(map(int, input().split())) for _ in range(n) ]
cnt=1

time.sort(key= lambda x : (x[1], x[0]) )


end_time=time[0][1]
# end시간과 start시간들 비교
for i in range(1,len(time)):
    start_time=time[i][0]
    # 끝나는 시간들은 이미 자동으로 안 겹치도록 오름차순 돼있고 시작시간도 오름차순으로 돼있다. 
    # 작은 시간부터 시작에서 안 겹치기 시작하는 시간을 고른다
    if start_time >= end_time:
        cnt+=1
        end_time=time[i][1]

print(cnt)






