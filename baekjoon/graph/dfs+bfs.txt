# visited >>> 정점 순대로 방문한 순서를 저장, 0으로 노방문
# graph >>> [ [],[], .... [] ] 이며 내부의 []가 하나의 노드를 뜻하고 내부[] 속 요소들이 이어지는 간선을 의미한다
위에 둘 다 n개의 정점을 위한다 (그래서 n+1 개씩 만듦)

# stack과 heap에 들어갔단 것 자체가 방문했단(visiited) 거다

# 이차원이면 dy,dx생각

dfs
visited에 넣고 graph에서 다음 꺼 찾고 dfs

bfs
deque에 넣는다 >> 넣은 index에 맞는 visited에 cnt 부여 >> (while 시작) deque에서 뱉는다 >> 뱉은 index에 맞는 graph에 오름차순 정렬 
>> 뱉은 index에 있는 것 중 안 간 index들 deque에 넣는다 >> 넣은 index에 맞는 visited에 cnt 부여 


[]*(n+1) 하면 []이 n+1 개 생기는 게 아니라 빈 공간이다. [0]*(n+1)이랑 비교, 이것의 결과는 [0*(n+1)]이다





함수

무슨 행위를 할 거고 무슨 행동부터 시작에서 무슨 행동까지다 라고 딱 규정, 그래야 바로 이 함수 내에서 또는 밖에서 바로 함수를 써도 주어진 역할만 충실히 한다

이 함수의 역할을 명확히 규정


dfs
visited가 동그라미 색칠된 것들이다
graph가 총 노드와 간선을 나타낸 것이고

dfs는 동그라미를 색칠(visited)하는 과정이다 그냥
동그라미를 색칠하고 다음에 어디를 색칠할까를 탐색하는 게 dfs의 only 주어진 역할

bfs
동그라미 색칠(visited)하고 deque에 append한다.
> deque 맨 앞을 pop한다
> pop된 번호의 간선들을 동그라미 색칠(visited) 하고 deque에 append한다

que는 다음 pop이 무엇인지를 알기 위해


그래프는 어떤 상태에 도달하기 위해 하는 것이다..
bfs는 두 가지가 있다. 첫째는 그래프처럼 횡적으로 차례대로 서순을 표시하는 것
두번째는 같은 위계에서는 모두 같은 cnt를 넣는다. cnt 없이 garpgh[i]=graph[out]+1 이런 식으로 한다>>dfs도 이런 식으로 하면 위계 별로 같은 값을 가지는 게 가능


